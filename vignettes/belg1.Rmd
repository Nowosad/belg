---
title: "belg: Boltzmann Entropy of a Landscape Gradient"
author: "Jakub Nowosad"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(ggplot2)
library(rasterVis)
theme_clean = function (base_size = 12, base_family = ""){
  theme_grey(base_size = base_size, base_family = base_family) %+replace% 
    theme(axis.line = element_blank(), axis.text.x = element_blank(), 
      axis.text.y = element_blank(), axis.ticks = element_blank(), 
      axis.title.x = element_blank(), axis.title.y = element_blank(), 
      axis.ticks.length = grid::unit(0, "lines"), legend.position = "none", 
      panel.background = element_blank(), panel.border = element_blank(), 
      panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
      panel.spacing = grid::unit(0, "lines"), plot.background = element_blank(), 
      strip.background = element_rect(colour = "#ffffff", 
        fill = "#eeeeee"))
}
theme_set(theme_clean())
```

<!-- intro to belg and the package -->
Boltzmann entropy (also called configurational entropy) has been recently adopted to analyze entropy of landscape gradients (Gao et al. (2017), Gao et al. (2018)).
The goal of **belg** is to provide an efficient C++ implementation of this method in R.
It also extend the original idea by allowing calculations on data with negative and missing values.

# Basic example

Let's take two small rasters - `complex_land` representing a complex landscape and `simple_land` representing a simple landscape.

```{r, message=FALSE}
library(raster)
library(belg)
```

```{r, fig.height=3, echo=FALSE}
gplot(complex_land) + 
  geom_tile(aes(fill = value), color = "black", size = 2) +
  geom_text(aes(label = value), size = 4) +
  coord_equal() +
  scale_fill_viridis_c() +
  labs(title = "Complex landscape")
gplot(simple_land) + 
  geom_tile(aes(fill = value), color = "black", size = 2) +
  geom_text(aes(label = value), size = 4) +
  coord_equal() +
  scale_fill_viridis_c() +
  labs(title = "Simple landscape")
```

The main function in this package, `get_boltzmann`, calculates the Boltzmann entropy of a landscape gradient:

```{r}
get_boltzmann(complex_land)
get_boltzmann(simple_land)
```

The results showed that the complex landscape has a larger value of the Boltzman entropy than the simple one.

The `get_boltzmann` function accepts a `RasterLayer`, `RasterStack`, `RasterBrick`, `matrix`, or `array` object as an input.
As a default, it uses a logarithm of base 10 (`log10`), however `log` and `log2` are also available options for the `base` argument.

```{r}
get_boltzmann(complex_land) # log10
get_boltzmann(complex_land, base = "log")
get_boltzmann(complex_land, base = "log2")
```

It also allows for calculation of the relative (the `relative` argument equal to `TRUE`) and absolute Boltzmann entropy of a landscape gradient.

# Relative Boltzmann entropy of a landscape gradient

<!-- main idea -->
<!-- explain the main idea in a few bullets -->

# Absolute Boltzmann entropy of a landscape gradient

<!-- how the previous values are recalculated -->

# Determining the number of microstates belonging to a defined macrostate

```{r}
ver_1 = raster(matrix(c(1, 3, 3, 4), ncol = 2))
ver_2 = raster(matrix(c(1, 3, 3, NA), ncol = 2))
ver_3 = raster(matrix(c(1, 3, NA, NA), ncol = 2))
ver_4 = raster(matrix(c(1, NA, NA, NA), ncol = 2))
ver_5 = raster(matrix(c(NA, NA, NA, NA), ncol = 2))
```

## Data without missing values

```{r, echo = FALSE}
gplot(ver_1) + 
  geom_tile(aes(fill = as.factor(value)), color = "black", size = 2) +
  geom_text(aes(label = value), size = 6) +
  scale_fill_manual(values = c("#fc8d59", "#ffffbf", "#91bfdb"))
```

```{r}
log10(24)
get_boltzmann(ver_1)
```

## Data with missing values

```{r, echo = FALSE}
gplot(ver_2) + 
  geom_tile(aes(fill = as.factor(value)), color = "black", size = 2) +
  geom_text(aes(label = c(1, 3, 3, "NA")), size = 6) +
  scale_fill_manual(values = c("#fc8d59", "#ffffbf", "#91bfdb"))
```

```{r}
log10(3)
get_boltzmann(ver_2)
```

```{r, echo = FALSE}
gplot(ver_3) + 
  geom_tile(aes(fill = as.factor(value)), color = "black", size = 2) +
  geom_text(aes(label = c(1, "NA", 3, "NA")), size = 6) +
  scale_fill_manual(values = c("#fc8d59", "#ffffbf", "#91bfdb"))
```

```{r}
log10(2)
get_boltzmann(ver_3)
```

```{r, echo = FALSE}
gplot(ver_4) + 
  geom_tile(aes(fill = as.factor(value)), color = "black", size = 2) +
  geom_text(aes(label = c(1, "NA", "NA", "NA")), size = 6) +
  scale_fill_manual(values = c("#fc8d59", "#ffffbf", "#91bfdb"))
```

```{r}
log10(1)
get_boltzmann(ver_4)
```

```{r, echo = FALSE}
gplot(ver_5) + 
  geom_tile(fill = "grey50", color = "black", size = 2) +
  geom_text(aes(label = c("NA", "NA", "NA", "NA")), size = 6) +
  scale_fill_manual(values = c("#fc8d59", "#ffffbf", "#91bfdb"))
```

```{r}
0
get_boltzmann(ver_5)
```

## References

- Gao, Peichao, Hong Zhang, and Zhilin Li. "An efficient analytical method for computing the Boltzmann entropy of a landscape gradient." Transactions in GIS (2018).
- Gao, Peichao, Hong Zhang, and Zhilin Li. "A hierarchy-based solution to calculate the configurational entropy of landscape gradients." Landscape Ecology 32(6) (2017): 1133-1146.
